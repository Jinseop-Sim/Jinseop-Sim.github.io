---
layout: post
title: "백준 1351 - 무한 수열"
categories: Baekjoon
tags: [cpp]
author:
  - Jinseop Sim
---
> [백준 1351 - 무한 수열](https://www.acmicpc.net/problem/1351)

이번 문제는 백준의 골드 5 문제 무한 수열문제이다.  
문제를 차근차근 한 번 읽어보자.  

어떤 수열의 값 An을 구하고 싶다.  
이 때, Ai = A(i/p) + A(i/q)이며, p와 q는 값이 주어진다.  
N의 최대 값은 ```10^12```이며, p와 q는 ```10^9```이다.  
굉장히 큰 값이기 때문에 시간 초과가 문제가 될 것 같다.  
문제를 어떻게 풀어나가야 할까?  

### 재귀
가장 먼저 든 생각은 재귀로 파고드는 것이다.  
우선 당연히 매우 큰 수 이기 때문에 ```long long``` 자료형을 사용한다.  
우리가 원하는 것은 An이기 때문에, ```n/p, n/q```로 파고들면 될 것같다.  

그럼 수는 어디에 저장해야 할까?  
배열에 저장하면서 나아간다면 어떨까?  
N의 최대 값이 ```10^12```이기 때문에 그건 불가능 할 것 같다.  
n번째 수열의 값을 곧바로 저장할 수 있는 자료구조는 없을까?  

바로 ```unordered_map```이 있다.  
이는 ```Hash table```과 동일한 자료구조로, 키를 통해 값을 불러올 수 있다.  
즉, ```Ai```에 대해 ```hash_table[i]```에 저장을 하여 값을 계산할 것이다.  

```A0 = 1```이라는 기저조건이 있으므로, 0이 되면 1을 반환하면 될 것 같다.  
0까지 쭉 재귀적으로 파고든 뒤, 위로 올라오며 값을 계산하도록 해보자.  
{% highlight cpp %}
unordered_map<ll, ll> hash_table;
ll calculate_sequence(ll target) {
	if (target == 0)
		return 1;

	hash_table[target] = calculate_sequence(target / p) + calculate_sequence(target / q);
	return hash_table[target];
}

int main() {
	cin >> n >> p >> q;

	calculate_sequence(n);
	cout << hash_table[n];
	return 0;
}

{% endhighlight %}  

위와 같이 구현해보았는데, 유감스럽게도 시간 초과가 발생했다.  
어떤 부분이 문제였을까?  

### 참조자(&)
결국 원인을 찾지 못하고 다른 사람들의 풀이를 참고했다.  
단순 재귀가 아닌 ```&``` 즉, 참조자의 사용이 필요했다.  

단순히 참조자 없이 변수를 사용하는 것과 어떤 차이가 있을까?  
만약 참조자 없이 그냥 아래의 코드를 실행시킨다면 어떨까?  


{% highlight cpp %}
unordered_map<ll, ll> hash_table;
ll calculate_sequence(ll target) {
	if (target == 0)
		return 1;

	ll& ret = hash_table[target];
	if (ret != 0)
		return ret;

	return ret = calculate_sequence(target / p) + calculate_sequence(target / q);
}

int main() {
	cin >> n >> p >> q;
	
	cout << calculate_sequence(n);
	return 0;
}
{% endhighlight %}  
