---
layout: post
title: "백준 2568 - 전깃줄 2"
categories: Baekjoon
tags: [cpp]
author:
  - Jinseop Sim
---
> [백준 2568 - 전깃줄 2](https://www.acmicpc.net/problem/2568)

이번 문제는 백준의 플래티넘 5 전깃줄 2 문제이다.  
이전에 ```전깃줄 1``` 문제를 푼 적이 있었는데, 해당 문제의 심화 버전이다.  
문제를 차근차근 읽어보도록 하자.  

번호가 순서대로 적힌 기둥이 있고, 해당 기둥에 전깃줄을 연결한다.  
단 해당 전깃줄들이 하나도 겹치지 않게 하고 싶다.  
최소 몇 개의 전깃줄을 제거해야 모든 전깃줄이 겹치지 않을 수 있을까?  

이 때 전깃줄은 최대 ```100,000```개가 주어질 수 있으며,  
각 기둥의 번호는 ```500,000``` 까지 가질 수 있다.  

### LIS
이전의 ```전깃줄 1``` 문제는 전형적인 ```LIS``` 문제였다.  
원리는 아래와 같다.  

모든 연결된 전깃줄을, 왼쪽 기둥 기준으로 오름차순 정렬한다.  
기둥의 번호는 순서대로 적혀있기 때문에, 정렬해도 지장이 없다.  

이제 오른쪽 기둥을 유심히 봐야한다.  
오른쪽 기둥은 분명 순서대로 정렬이 되어 있지 않을 것이다.  
하지만 잘 생각해보면, 오른쪽 기둥은 오름차순으로 정렬되어야 한다.  
왜? 그래야 전깃줄이 겹치지 않을 것이다.  

![image](https://github.com/Jinseop-Sim/Jinseop-Sim.github.io/assets/71700079/fe199255-b17b-4c5b-ad47-6a7d79977a2f)  
위의 그림과 같이 전깃줄이 연결되어 있다고 생각해보자.  
왼쪽은 이미 오름차순으로 정렬이 잘 되어있다.  
이 때, 오른쪽 기둥을 잘 살펴보면 겹치지 않는 전깃줄의 특징을 알 수 있다.  
```2 4 5 6 7``` 과 같이 오름차순으로 정렬이 되어야 한다는 점이다.  

따라서 이 문제를 푸는 핵심은 ```가장 긴 증가하는 부분 수열```과 같다.  

### 시간 복잡도
하지만 이번 문제는 ```전깃줄 2```로, 기존의 방식으로는 풀 수 없다.  
왜냐하면 주어지는 전깃줄의 수가 늘어났기 때문이다.  
또한 잘라야 하는 전깃줄을 차례로 출력해주어야 한다.  

기본적으로 동적계획법을 활용한 ```LIS```의 시간복잡도는 ```O(N^2)```이다.  
그럼 ```100,000```개의 전깃줄이 주어지는 경우엔 반드시 시간초과가 발생한다.  
즉, 우리는 시간복잡도를 ```O(N^2)``` 아래로 내려서 ```LIS```를 풀어야 한다.  

### 이분 탐색
```LIS```의 원리를 잘 생각해보자.  
하나의 수를 잡고 해당 수보다 앞에 있는 수 중 작은 수를 찾는 것이다.  
작은 수를 만났을 때, ```max(dp[i], dp[j] + 1)```을 통해 최대 길이를 갱신한다.  

