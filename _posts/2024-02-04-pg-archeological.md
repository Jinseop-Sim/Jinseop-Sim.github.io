---
layout: post
title: "프로그래머스 Level 3 - 고고학 최고의 발견"
categories: Programmers
tags: [cpp]
author:
  - Jinseop Sim
---
- [고고학 최고의 발견[LEVEL 3]](https://school.programmers.co.kr/learn/courses/30/lessons/131702)

이번 문제는 프로그래머스의 레벨 3 고고학 문제이다.  
문제를 한 번 차근차근 읽어보자.  

최대 ```8x8``` 크기의 암호판이 주어진다.  
암호판의 화살표를 시계 방향으로 돌려 모두 12시로 맞추어야 한다.  
암호판 하나를 돌리면 동서남북 네 방향의 화살표가 모두 돌아간다.  
암호를 풀 수 있는 최소 횟수를 구하라!  

어떤 식으로 문제를 풀어나가야 할까?  

### 완전 탐색?
가장 먼저 든 생각은 구현 + 완전탐색으로 풀면 되지 않을까? 이다.  
가운데 판 및 동서남북 방향의 판을 돌리는 것은 손쉽게 구현할 수 있다.  
하지만 문제는 어떤식으로 모든 판을 돌려볼 것인가이다.  

만약 이걸 백트래킹 방식으로 구현한다면 어떨까?  
백트래킹 방식을 적용하려면, 재귀에 대한 중지 조건이 반드시 필요하다.  
하지만 이 문제는 판을 최대로 돌릴 수 있는 횟수 같은 것이 정해져 있지 않다.  
즉 백트래킹을 중지할 수 있는 기준이 없으므로 사용할 수 없을 것 같다.  

```8x8``` 크기의 보드에서 고를 수 있는 칸은 총 64칸이다.  
이 때 1칸 ~ 64칸을 돌리는 경우까지 모두 직접 계산을 하면 얼마나 걸릴까?  
```1칸 : 64```, ```2칸 : 64C2``` ... ```64칸 : 64 C 64```가 된다.  
결국 ```64C1 + 64C2 + ... + 64C64```라는 식을 계산해야 한다.  
이는 ```nC1 + .. + nCn = 2^n``` 이라는 자명한 결과에 의해, ```2^64```가 된다.  
이는 터무니 없이 큰 수 이므로, 완전 탐색으로는 풀 수 없을 것 같다.  

### Greedy?
그리디로 풀 수 있지 않을까 잠시 생각해보았다.  
사실 우리는 이미 12시 방향으로 돌아가있는 판을 최대한 안돌리는게 이득이다.  
