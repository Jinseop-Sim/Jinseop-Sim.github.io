---
layout: post
title: "백준 20303 - 할로윈의 양아치"
categories: Baekjoon
tags: [cpp]
author:
  - Jinseop Sim
---
> [백준 20303 - 할로윈의 양아치](https://www.acmicpc.net/problem/20303)

이번 문제는 백준의 골드 3, 할로윈의 양아치 문제이다.  
문제를 한 번 차근차근 읽어보도록 하자.  

최대 ```30000명```의 아이와 ```100000개```의 관계가 주어진다.  
이 때, ```K```명 이상의 아이의 사탕을 뺏으면 어른들이 알게 된다.  
어른들이 모르게 최대 몇 개의 사탕을 뺏을 수 있을까?  

### 그룹화
가장 먼저 든 생각은 아이들을 그룹화 해야겠다는 생각이다.  
어떤 아이의 사탕을 뺏았을 때, 관계가 있는 모든 아이의 사탕을 뺏는다.  
그럼 해당 아이들은 모두 같은 그룹으로 보면 될 것이다!  

이 부분은 유니온 파인드를 이용해서 구현하면 좋겠다고 생각했다.  
유니온 파인드는 ```분리 집합``` 알고리즘이라고도 불린다.  
지금 우리는 서로 분리된 집합을 만드려는 것이니, 적합할 것 같다!  
해당 부분은 아래와 같이 구현했다.  
{% highlight cpp %}
init_groups();
	for (int i = 1; i <= num; i++)
		cin >> groups[i].second;
	// 그룹화를 하기 위해 초기화

	for (int i = 0; i < edges; i++) {
		cin >> from >> to;
		do_union(from, to);
		// 사이클 체크가 필요할까?
	}

	for (int i = 1; i <= num; i++) {
		int target = groups[i].first;
		int target_candy = groups[i].second;

		if (duplication_preventer[target]) {
			duplication_preventer[target]++;
			continue;
		}

		group_store.push_back({ target, target_candy });
		duplication_preventer[target] = true;
	}
{% endhighlight %}

유니온 파인드를 통해서 분리 집합을 구성해주고,  
각 집합의 사탕 수와 대표를 ```vector```를 이용해 저장해준다.  
```map```은 중복 검사에 사용되며, 각 집합의 인원 수를 저장하기도 한다.  
이렇게 되면 이제 모든 집합의 정보가 저장이 되었다.  
이제 관건은 이 정보를 통해 어떻게 최대값을 찾을 수 있는가이다.  

### 완전탐색?
모든 집합을 고르는 경우를 다 생각해보고 그 중에 최대를 고를 수 있을까?  
완전 탐색으로 진행했을 때 시간 초과가 발생하지 않을까?  

탐색 시간이 최악이 되는 경우는 모든 학생이 분리되어 있을 때일 것이다.  
```30000명```의 학생이 모두 분리된다면 모두 탐색하는 데에 얼마나 걸릴까?  
```30000명```을 중복 없이 모두 고르는 경우의 수는 굉장히 많을 것이다.  

만약 최소 값을 구하는 것이었다면, 중지 조건에 의해 시간 단축이 되겠지만  
최대 값을 구하는 완전 탐색이기 때문에 시간 초과를 피할 수 없을 것 같다.  

### Greedy?
그리디하게 문제를 풀 수는 없을까?  
간단하게 생각해서, 인원 수가 작은 집합부터 오름차순으로 정렬을 해보자.  
이제 앞에서부터 차례대로 선택을 했을 때가 최대가 될까?  

만약 ```10명``` 이하의 아이만 건드릴 수 있다고 생각해보자.  
```1(1) 6(4) 7(5) 40(6)```와 같이 사탕 수, 인원 수가 정해져있다.  
그럼 우리는 그리디하게 선택을 하니 최대가 ```14개```라고 판단할 것이다.  
하지만 사실 정답은 ```1 + 40```을 할 수 있는 경우가 된다.  

이런 예외 케이스에 의해 이 문제는 그리디하게 풀 수 없다.  

### DP?
그럼 또 다른 최대, 최소를 구할 수 있는 방식인 동적 계획법은 어떨까?  
