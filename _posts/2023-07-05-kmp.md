---
layout: post
title: "KMP 알고리즘 완벽하게 숙지하기"
categories: Algorithm
tags: [cpp]
author:
  - Jinseop Sim
---
어떤 문자열에서 특정 단어를 찾는 알고리즘은 굉장히 많이 존재한다.  

- Naive, 단순 이중 포문
- KMP Algorithm : 이번에 익힐 접두 / 접미사를 이용한 알고리즘이다.
- Rabin & Karp Algorithm : 해쉬를 이용한 알고리즘이다.
- Boyer & Moore Algorithm : 굉장히 어려운 알고리즘이다.
- Manber-Myers Algorithm : 접미사 배열을 이용한 알고리즘이다.  

위 알고리즘들 중에서 이번에는 __KMP__ 알고리즘을 완벽히 숙지해보려고 한다.  

## KMP?
KMP(Knuth, Morris, Prett) 알고리즘이란 무엇일까?  

먼저 위에서 언급했듯이, 어떤 문자열에서 특정 단어를 찾으려면 얼마나 걸릴까?  
길이 N의 문자열에서 길이 M의 단어를 찾는다고 생각해보자.  
그럼 아래와 같이 코드를 작성해 볼 수 있을 것이다.  
{% highlight cpp %}
for (int i = 0; i < src.size() - dest.size(); i++) {
	for (int j = 0; j < dest.size(); j++) {
		if (src[i + j] != dest[j]){
			break;
      isSame = false;
    }
	}
  if(isSame)
     cout << "Same String! << "\n";
}
{% endhighlight %}  

최악의 경우 N의 길이를 M만큼 모두 뒤져야하니, O(NM)의 시간복잡도가 발생한다.  
이는 문자열의 길이가 길면 길수록 너무 많은 시간을 잡아먹는 알고리즘이다.  

이런 문제점을 개선하기 위해 고안된 것이 바로 __KMP 알고리즘!__  
접두사와 접미사의 개념을 통해 불필요한 탐색을 모두 제외하고 탐색하는 알고리즘이다.  
결론부터 말하자면, O(NM)에서 O(N+M)까지 시간복잡도 개선이 가능한 알고리즘이다.  
