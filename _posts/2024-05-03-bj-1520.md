---
layout: post
title: "백준 1520 - 내리막 길"
categories: Baekjoon
tags: [cpp]
author:
  - Jinseop Sim
---
> [백준 1520 - 내리막 길](https://www.acmicpc.net/problem/1520)  

이번 문제는 백준의 골드 3 문제 내리막 길 문제이다.  
문제를 차근차근 한번 읽고 풀어보도록 하자.  

최대 ```500 X 500``` 크기의 지도가 주어진다.  
이 때, 상하좌우를 이동하며 오른쪽 아래 모서리까지 이동하려고 한다.  
단, 오르막길은 힘들기에 반드시 내리막길로만 이동하려고 한다!  
주어진 지도에 대해 높이가 낮은 곳으로만 이동하는 것이다.  

이 때, 내리막길로만 이동할 수 있는 경로의 수를 계산하라!  

### DP?
보통 지도 상에서 경로의 수를 계산하는 것은 동적 계획법으로 해결한다.  
2차원 배열인 ```DP[i][j]```를 선언하여, 각 칸에 대해 경로를 계산하는 것이다.  
이전 경로에 대해서 ```(i, j)``` 까지 오는 경로의 수를 더해가는 것이다.  

하지만 이번 문제는 조금 다르다.  
위의 논리가 적용이 되려면, 사용자는 아래와 오른쪽으로만 움직여야 한다.  
왼쪽이나 위로 움직이는 경우는 저런 방식으로 계산할 수 없는 것이다.  

그럼 어떤 방식으로 풀어야 할까?  

### BFS?
그래프의 상하좌우를 모두 탐색할 수 있는 알고리즘은 BFS, DFS가 있다.  
둘 중 하나의 방식으로 그래프를 훑으며, ```Memoization```을 진행해야 할 것 같다.  
과연 BFS와 DFS 둘 중 어느 알고리즘을 적용해야할까?  

먼저 BFS에 대해서 생각을 해보자.  
BFS를 이용해서 시작지점부터 ```상, 하, 좌, 우```를 훑으며 탐색을 진행한다.  
```Memoization```의 원리를 생각해보았을 때, ```이전 단계```의 경로 수를 알아야 한다.  
하지만 BFS를 이용하는 경우, ```이전 단계```와 이어지는 연속성을 이용할 수가 없다.  

그럼 DFS에 대해서 한 번 생각해보도록 하자.  

### DFS!
DFS는 ```상, 하, 좌, 우``` 순서가 아닌 깊이를 우선으로 탐색하는 방식이다.  
따라서, ```이전 단계```의 경우의 수를 계속 추적할 수 있다.  
하지만, ```도착점에 도착할 수 있는 경로```의 수를 정하는 것이니, 거꾸로 생각해야 할 것 같다.  
재귀 함수를 선언하되, 다음 경로가 내리막길이라면 ```1```을 반환해서 배열에 더하도록 하는 것이다.  

