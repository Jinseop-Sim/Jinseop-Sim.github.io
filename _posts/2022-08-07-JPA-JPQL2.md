---
layout: post
title: "스프링 JPA - JPQL 2"
categories: Springboot
tags: [java]
author:
  - Jinseop Sim
toc: true
---
저번 JPQL 강의에 이어서 JPQL에 대해서 알아보자.  

### 경로 표현식
우리가 흔히 SQL 문법을 쓸 때 ```.```을 찍어 탐색하는 것을 말한다.  

- 상태 필드 : 단순히 값을 저장하기 위한 필드이다.
  - 경로 탐색의 끝이며, 더 이상 탐색을 진행하지 않는다.
  - ```m.username```과 같은 필드이다.
- 연관 필드 : 연관관계를 위한 필드이다.
  - 단일 값
    - ```@ManyToOne, @OneToOne``` 처럼, 대상이 단일 Entity일 때.
    - ```SELECT m.team FROM Member m```과 같이 묵시적으로 INNER JOIN이 발생한다.
      - 따라서 조심해서 사용을 해야한다 !
    - 상태 필드와 다르게, 더 깊게 탐색이 가능하다.
  - 컬렉션 값
    - ```@OneToMany``` 처럼, 대상이 Collection 값일 때
    - 단일 값과 같이 묵시적 INNER JOIN이 발생한다.
    - 상태 필드와 같이, 값이 많아서 더 깊게 탐색이 불가능하다.
    - 만약, 더 탐색을 하고 싶다면 명시적으로 JOIN을 하자!
      - ```SELECT m.name FROM Team t JOIN t.members m```과 같이.

__웬만하면 묵시적 조인은 절대 쓰지말것!!__  
참고로, 묵시적 조인은 INNER JOIN만 가능하다.  

### Fetch JOIN
SQL에는 없는, JPQL만의 Fetch JOIN에 대해 알아보자.  
JPQL에서 성능 최적화를 위해 제공하는 기능으로,    
연관된 엔티티나 Collection을 SQL 한번으로 함께 조회하는 기능이다.  
실무에서 정말 많이 사용한다!  

{% highlight java %}
String query = "SELECT m FROM Member m";
List<Member> result = em.createQuery(query, Member.class)
        .getResultList();
for(Member member : result){
    System.out.println("member = " + member.getUsername() + ", "
                    + member.getTeam().getName());
}
{% endhighlight %}  

위와 같이 Query문을 작성하게 되면, N+1 문제가 불가피 해진다!  
회원 100명이 각자 다른 팀에 소속해서 Query를 조회할 경우, 총 101번의 Query가 나간다는 것이다.  

하지만, ```JOIN Fetch```를 사용하는 경우엔, Query 한 번에 모든 Data를 조회한다.  
한 번에 Context에 영속시키기 때문에, 더 이상의 Query는 보내지 않는다.  