---
layout: post
title: "스프링 JPA - Basic"
categories: Springboot
tags: [java]
author:
  - Jinseop Sim
toc: true
---

JPA는 __Java Persistence API__ 의 약자로, Java의 ORM 기술 표준이다.  
ORM이란, 객체 관계 매핑(Object-Relational Mapping)이란 의미로,  
객체와 DB를 따로따로 설계를 하고 ORM Framework가 그 둘을 Mapping을 해준다.

JPA는 객체와 RDB간의 Mapping과 영속성 컨텍스트에 대해 이해 하는 것이 가장 중요하다.  

### 영속성 컨텍스트
JPA를 이용하는데에 가장 중요한 용어인 __영속성 컨텍스트__ 이다.  
```em.persist(entity)``` 이는 "Entity를 영구 저장하는 환경" 이라는 의미를 가진다.  

### Entity의 생명주기  
![image](https://user-images.githubusercontent.com/71700079/181255771-2a95c162-c775-41bc-a71c-474b6c4a7029.png)  
- 비영속 : 영속성 컨텍스트와 관계가 없음.
  - Entity가 생성만 된 상태이다.
- 영속 : 영속성 컨텍스트에 관리되는 상태.
  - Persist를 통해서 Entity가 Context에 영속된 상태이다.
  - 영속이 된다고 해서, DB로 Query가 바로 날아가는 것은 아니다.
  - Transaction에 Commit을 해야만 Query가 그제서야 DB로 날아간다.
- 준영속 : 영속성 컨텍스트에 저장되었다 분리된 상태.
- 삭제 : 말 그대로 삭제된 상태.

### 영속성 컨텍스트의 장점
- 1차 Cache  
  ![image](https://user-images.githubusercontent.com/71700079/181255866-aa83046d-c2cd-4053-bc5d-bb7154b35aae.png)  

  - 영속 컨텍스트에 등록 시, Cache에 Entity를 저장하는 것과 동일한 효과를 낸다.  
  - ```em.find(Member.class, "member")```와 같이 조회 시, Cache에서 바로 조회를 한다.
  - 로그를 찍어보면, 조회 Query가 사용되지 않음을 알 수 있다.
- 동일성(Identity) 보장
  - 서로 다른 객체에 동일 Entity를 조회하면, 둘은 동일함을 보장한다.
- Transaction을 지원하는 쓰기 지연(Write-Behind)
  - Persist를 하는 것만으로는 DB에 Insert Query를 보내지 않는다.
    - 이 때는, 영속 컨텍스트의 1차 __캐시와 쓰기 지연 SQL 저장소__ 에 담기만 한다.
  - Transaction을 Commit 하는 순간, 한 번에 모든 Query를 보낸다.

- 변경 감지(Dirty Checking)  
  ![image](https://user-images.githubusercontent.com/71700079/181256001-43282fa0-1d2c-4946-af9d-f8a429683f36.png)  

  - 내가 DB의 Data를 변경하고 싶다면, 그냥 변경만 해주면 된다.
  - 변경한 뒤, 굳이 다시 Persist하거나 DB에 처리해 줄 필요가 없다는 것이다.
  - 알아서 감지하고 Update Query를 날린다는 것!

##### Flush?
영속성 컨텍스트의 변경 내용을 DB에 반영하는 것을 __Flush__ 라고 한다.  

- ```em.flush()``` 로 직접 호출할 수 있다.
- Transaction Commit 시에, 자동으로 호출된다.
- JPQL Query를 날릴 때, 자동으로 호출된다.

Flush가 호출되면, 강제로 모든 Query가 DB에 반영되게 된다.  

### 객체와 Table 매핑

> - 사진 및 자료 출처 : [김영한의 스프링 JPA 기초](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)
