---
layout: post
title: "Divide & Conquer"
categories: Algorithm
tags: [cpp]
author:
  - Jinseop Sim
---
__Divide & Conquer,__ 분할 정복 알고리즘에 대해 공부해보자.  

먼저 __분할 정복법이란__ 무엇일까?  
간단히 말하면, 크고 복잡한 문제를 작은 소문제로 쪼개어 문제를 풀어 나가는 것이다.  
어디선가 많이 들어본 말인 것 같다.  

바로 __동적 계획법(DP)과__ 굉장히 유사한 개념임을 알 수 있다.  
하지만 분할 정복법은 동적 계획법과는 아래와 같은 차이가 존재한다.  

|-|동적 계획법|분할 정복법|
|:--:|:--:|:--:|
|공통점|큰 문제를 작은 문제로|쪼개어 풀어나간다.|
|차이점|Memoization이 사용된다.|Memoization이 사용되지 않는다.|
|-|쪼개진 소문제가 중복된다.|쪼개진 소문제는 중복되지 않는다.|

### Memoization이란?
Memoization이란, 동적 계획법의 핵심이자 꽃이다.  
이전 단계의 결과를 기억하여 다음 계산에 사용하는 것을 의미한다.  

피보나치 수열을 예시로 들어서 생각해보자.  
피보나치 수열은 ```f(n) = f(n-1) + f(n-2)```를 점화식으로 갖는다.  
매우 유명한 점화식이기 때문에, 많은 사람들이 이미 알고있으며,  
피보나치 수열을 풀 때 재귀 뿐만 아니라 DP로도 풀 수 있음이 이미 자명하다.  

해당 점화식에 Memoization을 어떻게 적용할 수 있을까?  
바로 배열에 ```f(n)``` 값을 저장하며 앞으로 채워나가는 것이다.  
반복문을 돌며 ```f[n] = f[n-1] + f[n-2]```와 같이 채워나간다면?  
이전 단계에서 저장된 ```f[n-1], f[n-2]```가 다음 계산에 사용되게 된다.  

이와 같은 방식을 동적 계획법의 Memoization이라고 한다.  

### 분할 정복의 Memoization?
분할 정복은 소문제의 결과를 어딘가에 저장하거나 하지 않는다.  
배열과 같은 메모리를 이용하지 않고, 재귀 함수를 통해 곧바로 결과를 이어받는다.

## 분할 정복 대표 문제
### 쿼드 트리
{%highlight cpp%}
{%endhighlight%}
### 하노이의 탑
{%highlight cpp%}
{%endhighlight%}
### 거듭 제곱
{%highlight cpp%}
{%endhighlight%}
