---
layout: post
title: "Shortest Path : Dijkstra Algorithm"
categories: Algorithm
tags: [cpp]
author:
  - Jinseop Sim
---

### Dijkstra Algorithm
> 하나의 정점에서 출발했을 때, 다른 모든 정점으로의 최단 경로를 구하는 Algorithm이다.  

- DP를 활용한 대표적인 최단경로 탐색 Algorithm이다.
  - 흔히 인공위성, GPS 등에 가장 많이 사용된다.
- 간선의 가중치는 음수가 될 수 없다.
  - 따라서 현실세계에 가장 적합한 Shortest Path Algorithm이다.

  ### Example : Basic Dijkstra, O(N^2)
- 아래와 같은 Graph가 있다고 생각해보자.  
![image](https://user-images.githubusercontent.com/71700079/175264507-93e80c60-9106-4093-aecd-257ef6577319.png)   

- STEP 1
  - 출발 정점을 1이라고 했을 때, 제일 처음엔 출발 노드로부터 이어진 다른 Node까지의 모든 비용을 저장한다.  
![image](https://user-images.githubusercontent.com/71700079/175264764-d0ff0d91-3562-4ac7-bb8a-6758c33735aa.png)  
    - 그럼 위와 같은 표가 만들어진다.
- STEP 2
  - 이제 최단 경로를 찾을 수 있도록 계속 갱신을 해야한다.
    - 방문하지 않은 Node중에서 가장 비용이 적은 4번 Node부터 들려서 갱신을 해보자.
    - 4번 Node를 거쳐서 갈 수 있게 된 Node나, 더 나은 경로가 있으면 아래와 같이 갱신한다.  
  ![image](https://user-images.githubusercontent.com/71700079/175265115-9767d8c6-9e96-4404-83eb-4f9d1ba888a0.png)  
- STEP 3
  - 남은 미 방문 Node들도 모두 돌며 똑같이 반복한다.
    - 최종적으로 갱신이 완료된 시점의 최단 경로 표는 아래와 같다.  
  ![image](https://user-images.githubusercontent.com/71700079/175265357-611242c0-10e9-48c2-ad66-81243e35673d.png)
- 구현 Code는 아래와 같다.

{% highlight cpp %}
#include <iostream>
#include <vector>
using namespace std;
#define INF 1000000000

int nodes = 0, edges = 0, start = 0;
vector<pair<int, int>> graph[100001]; // 연결된 node와 weight
bool visit[100001];
int dist[100001];

// 자신을 제외한 방문하지 않은 Node 중 weight이 가장 작은 Node 번호.
int which_smallest() {
    int min = INF;
    int idx = 0;

    for (int i = 0; i <= nodes; i++) {
        if (dist[i] < min && !visit[i]) {
            min = dist[i];
            idx = i;
        }
    }
    return idx;
}

void dijkstra(int start) {
    dist[start] = 0; // 자신의 거리는 0으로 초기화
    visit[start] = true; // 자신은 방문한 것으로 표시

    for (int i = 0; i < graph[start].size(); i++) {
        dist[graph[start][i].first] = graph[start][i].second;
    } // 거리 배열에, 시작 node와 연결된 모든 Node까지의 가중치 적립.

    for (int i = 0; i < nodes - 1; i++) {
        int curr_node = which_smallest();
        visit[curr_node] = true;
        // 방문하지 않은 node 중 가중치가 가장 적은 node 선택

        for (int j = 0; j < graph[curr_node].size(); j++) {
            int cost = dist[curr_node] + graph[curr_node][j].second;
            // 현재 지정된 node와 연결된 다른 node와의 거리를 더해본다.
            // ex) curr_node가 2면, 1 - 2 - 4 & 1 - 2 - 3 으로 두 번 돈다.

            if (cost < dist[graph[curr_node][j].first]) {
                dist[graph[curr_node][j].first] = cost;
                // 만약 해당 경로에 대해서 원래 dist 배열의 가중치보다 cost가 작다면,
                // 교체 한다.
                // ex) curr_node가 1 - 4 보다, 1 - 2 - 4가 더 짧은 거리이면 교체.
            }
        }
    }
}

int main() {
    cin >> nodes >> edges >> start;
    
    for (int i = 0; i < edges; i++) {
        int u = 0, v = 0, weight = 0;
        cin >> u >> v >> weight;
        graph[u].push_back(make_pair(v, weight));
    } // 입력

    fill_n(dist, 100001, INF); // 초기 Dist는 모두 INF로 초기화
    dijkstra(start);
    
    for (int i = 1; i <= nodes; i++) {
        if (dist[i] == INF) cout << "INF" << '\n';
        else cout << dist[i] << '\n';
    }

    return 0;
}
{% endhighlight %}