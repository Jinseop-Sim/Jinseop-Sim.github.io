---
layout: post
title: "백준 9177 - 단어 섞기"
categories: Baekjoon
tags: [cpp]
author:
  - Jinseop Sim
---
> [백준 9177 - 단어 섞기](https://www.acmicpc.net/problem/9177)

이번 문제는 백준의 골드 4 문제 단어 섞기 문제이다.  
문제를 차근차근 한 번 읽어보자.  

두 단어를 섞어 주어진 단어를 만들 수 있는지 판단해야 한다.  
단, 원래 단어의 순서는 유지되어야 한다.  
최대 1000개의 데이터가 주어지며, 단어는 400글자가 최대이다.  

주어지는 데이터의 수가 그렇게 크지 않으니 다양하게 생각해보자.  
문제를 어떻게 풀어나가야 할까?  

### 포인터의 활용
처음 든 생각은 포인터를 총 3개 만들어 탐색하는 것이다.  
주어지는 2개의 단어를 짚을 포인터 2개 그리고, 타겟용 하나.  
3개의 포인터를 앞으로 옮겨가며 탐색하는 것은 어떨까?  

타겟의 포인터를 기준으로 해당 알파벳이 주어진 단어에 있으면,  
해당 단어의 포인터만 앞으로 한 칸 옮기는 것이다.  
그럼 순서는 반드시 지켜질 것이고, 어차피 중복되는 알파벳이  
나오더라도 반드시 두 번 타겟에 등장해야 하기 때문에,  
괜찮은 로직이라고 생각된다. 한 번 구현해보자.  

{% highlight cpp %}
int src1_ptr = 0, src2_ptr = 0;
for (int target_ptr = 0; target_ptr < target.size(); target_ptr++) {
    if (target[target_ptr] == src1[src1_ptr])
        src1_ptr++;
    else if (target[target_ptr] == src2[src2_ptr])
        src2_ptr++;
}

if(src1_ptr == src1.size() && src2_ptr == src2.size())
    cout << "Data set " << (i + 1) << ": yes";
else
    cout << "Data set " << (i + 1) << ": no";
{% endhighlight %}

위와 같이 로직을 구현해보았는데, 문제가 생겼다.  
만약 ```cat tree catrtee```가 주어졌다고 생각해보자.  
내 로직대로라면, ```cat```을 먼저 찾아버리면 ```rtee```가 남아  
만들 수 없는 단어가 되어버린다, 하지만 실제론 그렇지 않다.  
```ca```를 찾은 뒤 ```tr```을 찾으면, 가능한 타겟임을 알 수 있다.  

그래서 둘 다 가능한 알파벳일 때 분기를 하나 더 추가했다.  
포인터의 진행도가 더 낮은 단어의 포인터를 늘려주는 것이다.  
하지만 안타깝게도 이 로직은 실패했다.  
사실 반례를 찾지 못해서 어떤 부분이 틀린 것인지 아직 모르겠다.  

### DP
조금 더 생각하다 다른 사람의 풀이를 참고했다.  
사실 이 문제는 DP 문제라고 한다.  
