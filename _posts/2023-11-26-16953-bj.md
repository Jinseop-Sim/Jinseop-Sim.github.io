---
layout: post
title: "백준 16953 - A -> B"
categories: Baekjoon
tags: [cpp]
author:
  - Jinseop Sim
---
> [백준 16953 : A -> B](https://www.acmicpc.net/problem/16953)  
오늘부터 랜덤하게 백준 문제를 푼 뒤, 알고리즘을 풀어나가는 과정을 기록한다.  
문제를 무작정 많이 풀어나가기 보다는 내가 무슨 생각을 하는지 관찰해보자.  

백준에 있는 실버 2 티어 문제 ```A -> B```이다.  
어떤 정수 A를 B로 바꾸는 데에, 최소 몇 번의 연산이 필요한 지 묻고 있다.  
연산의 종류는 ```X2, N1```이다.  

나는 이런 문제를 풀 때, 주어진 조건의 범위를 가장 먼저 봐야한다고 생각한다.  
![image](https://github.com/Jinseop-Sim/Jinseop-Sim.github.io/assets/71700079/3278489d-d540-45f3-9363-80cf29917af8)  
문제에 보면, 위와 같이 ```10^9``` 즉, 10억의 범위를 가진다.  
이는 연산을 진행했을 때, 정수형의 최대 범위인 21억을 넘을 가능성이 있으므로,  
우선 ```long long``` 자료형을 사용해야할 것 같다.  

그럼 이제 문제의 로직을 한 번 생각해보자. 어떤 식으로 풀어야 할까?  
단순히 for문을 이용해서 풀 수 있을까? 한 번 생각해보았다.  
```X2```에 대한 연산은 for문의 iterator를 이용하여 계산할 수 있다.  
하지만 ```N1```과 같이 숫자 뒤에 1을 붙여야 하는 연산은?  
단순히 for문으로는 계산할 수 없다.  

그럼 재귀함수를 이용해서 계산을 하며 넘겨주는 건 어떨까?  
시작하는 A와 B의 차이가 매우 클 때, Stack overflow의 위험이 살짝 걱정된다.  
한 번 진행해보자.  
{%highlight cpp%}
#define ll long long
ll start = 0, target = 0, answer = 999999999;
bool isPossible = false;
void recursion(ll depth, ll result) {
    if (result == target) {
        isPossible = true;
        answer = min(answer, depth);
        return;
    }

    if (result > target)
        return;

    recursion(depth + 1, result * 2);

    string temp = to_string(result);
    temp = temp + '1';
    recursion(depth + 1, stoll(temp));
}

int main(){
    cin >> start >> target;
    
    recursion(1, start);

    if (isPossible)
        cout << answer;
    else
        cout << -1;
    return 0;
}
{%endhighlight%}  
위의 코드로 예제를 돌려보니 모두 잘 나옴을 확인했다.  
제출을 했을 때, 운이 좋게도 정답이었다!  
